## 3 栈和队列
栈是一种操作受限的线性表，只允许在一端(即栈顶)插入和删除数据。 所以栈的数据是先进后出，后进先出
队列是一种只允许在前端进行删除操作、在后端进行插入操作的特殊线性表。先进后出

### 3.1 形式和变形
#### 3.1.1 顺序栈
利用数组实现的栈即为顺序栈。在go中只利用数组创建栈，会限制栈的容量，无法动态扩容， 以下使用slice实现

```
go test -v ./ -run TestArrayStack
```

### 3.1.2 链式栈
利用链表实现的栈即为链式栈

```
go test -v ./ -run TestLinkedListStack
```

### 3.1.3 顺序队列

```
go test -v ./ -run TestArrayQueue
```

#### 3.1.4 链式队列
```
go test -v ./ -run TestLinkedListQueue
```

#### 3.1.5 循环队列
纯数组实现(不用slice)时，入队出对需要搬移，n较大时，较为耗时，可以在抽象层面上将队头 队尾相连， 队头、队尾索引动态改变
```
go test -v ./ -run TestCircularQueue
```

#### 3.1.6 阻塞队列
阻塞队列模型通常用于CSP模型的并发编程，它可以平衡生产者和消费者两端的速度。当队列已满时，生产者会停止入队，直到有消费者消费队列。当队列为空时，消费者操作会被阻塞，直到有生产者入队。
阻塞队列根据实现方式，存储容量可以分为：
ArrayBlockingQueue：由数组结构组成的有界阻塞队列，
LinkedBlockingQueue：由链表结构组成的有界（默认大小是int32最大值）阻塞队列。
PriorityBlockingQueue：支持优先级排序的无界阻塞队列。
DelayQueue：使用优先级队列支持延迟的无界阻塞队列。
SynchronousQueue：不存储元素的队列，也即单个元素的队列。没有容量，每一个put操作必须等待一个take操作，否则不能添加元素，反之亦然。
LinkedTransferQueue：由链表结构组成的无界阻塞队列。
LinkedBlockingDeque：由链表结构组成的双向阻塞队列。

GO是一个天然支持并发的编程语言，它对于CAP和传统的并锁模式都是支持的。go中的channel无缓存模式并非阻塞队列，可以看做一种阻塞式缓存。 而channel的缓存模式则是一种由循环数组实现
更多go的channel分析请参考大神的 [由浅入深剖析go channel](https://www.jianshu.com/p/24ede9e90490)

#### 3.1.7 并发队列
在普通队列上加锁，保证同一时间只有一个出队入队，就是有锁的并发队列
循环队列是一种无锁的并发队列

------

### 3.2 自算法
#### 3.2.1 翻转栈的元素
***链式栈的翻转***
对于双向链表实现的栈而言，只需要将链表翻转就可以

```
go test -v ./ -run TestLinkedListStackReverse
```

***顺序栈翻转*** 
对于slice实现的栈而言，可以翻转slice，也可以从栈里弹出数据存储到新的slice里， 以下采用弹出式

```
go test -v ./ -run TestArrayStackReverse
```

------

### 3.3 逻辑算法
#### 3.3.1 O(1)复杂度求出栈中最小、最小值
思路： 空间换时间，多存两个值，专门用于存储最大 最小值
```
go test -v ./ -run TestMaxMin
```

#### 3.3.2 根据入栈序列判断可能的出栈序列
思路： 
* A为入栈序列Slice，B为检测序列Slice；
* 将A以此存入A Stack, 直到A Stack栈顶元素等于B第一个元素，A Stack出站，B向后移
* 如果A Stack栈顶元素依然等于B当前元素，A Stack出站，B后移。如果不等，A Stack出站，B不移动
* 直到A全部入栈，判断B是否已经全部遍历， 如果全部遍历， 则B是可能的出栈序列，反之不是

```
go test -v ./ -run TestPossibleSequence
```

#### 3.3.3 符号匹配
一个字符串中只包含三种符号:圆括号()、方括号[]及花括号{}, 如何判断这三种在字符串中都闭合了，且嵌套有序
思路： 遍历字符串， 左符号入栈， 碰到右符号则弹出栈顶， 判断是否是匹配的左符号

```
go test -v ./ -run TestTestMarkMatch
```

#### 3.3.4 双栈实现队列
思路：
* 创建两个栈A B， A代表入队顺序， B代表出队顺序
* 入队操作，先对B依次出队，插入A中，最后再将当前数据插入A
* 出队操作，对A依次出队，插入B中，最后一个就是要出队的数值

```
go test -v ./ -run TestStackImitateQueue
```


#### 

----


### 3.4 实用算法


-----

### 3.5 总结
#### 3.5.1 栈

#### 3.5.2 队列